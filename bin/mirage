#!/usr/bin/env ruby
require 'rubygems'
$LOAD_PATH.unshift("#{File.dirname(__FILE__)}/../lib")
require 'mirage'
require 'childprocess'
include Mirage::Util
RUBY_CMD = RUBY_PLATFORM == 'java' ? 'jruby' : 'ruby'


def start_mirage(args)
  puts "Starting Mirage"

  if windows?
    command = ["cmd", "/C", "start",  "\"mirage server\"", RUBY_CMD, "#{File.dirname(__FILE__)}/../lib/start_mirage.rb"]
  else
   command = [RUBY_CMD, "#{File.dirname(__FILE__)}/../lib/start_mirage.rb"]
  end
  ChildProcess.build(*(command.concat(args))).start
  Mirage::Client.new "http://localhost:#{parse_options(ARGV)[:port]}/mirage"
end


def mirage_process_ids
  ["Mirage Server", 'start_mirage'].collect do |process_name|
    `ps aux | grep "#{process_name}" | grep -v grep`.split(' ')[1]
  end.find_all{|process_id| process_id != $$.to_s}.compact
end

def stop_mirage
  if windows?
    process_id = `tasklist /V | findstr "mirage\\ server"`.split(' ')[1]
    `taskkill /F /T /PID #{process_id}` if process_id
  else
    begin
      mirage_process_ids.each do |process_id|
        system "kill -9 #{process_id}"  
      end
    rescue
      puts 'Mirage is not running'
    end
  end
end

if ARGV.include?('start')
  
  unless mirage_process_ids.empty?
    puts "Mirage is already running"
    exit 1
  end

  mirage_client = start_mirage(ARGV)
  wait_until do
    mirage_client.running?
  end
  
  begin
    mirage_client.prime
  rescue Mirage::InternalServerException => e
    puts "WARN: #{e.message}"
  end

elsif ARGV.include?('stop')
  puts "Stopping Mirage"
  stop_mirage
else
  parse_options ['--help']
  exit 1
end
