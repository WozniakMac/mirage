#!/usr/bin/env ruby
require 'rubygems'
$LOAD_PATH.unshift("#{File.dirname(__FILE__)}/../lib")
require 'mirage'
require 'childprocess'
include Mirage::Util
RUBY_CMD = RUBY_PLATFORM == 'java' ? 'jruby' : 'ruby'


def start_mirage(args, mirage)
  puts "Starting Mirage"

  if windows?
    command = ["cmd", "/C", "start",  "\"mirage server\"", RUBY_CMD, "#{File.dirname(__FILE__)}/../lib/start_mirage.rb"]
  else
   command = [RUBY_CMD, "#{File.dirname(__FILE__)}/../lib/start_mirage.rb"]
  end
  ChildProcess.build(*(command.concat(args))).start

  wait_until do
    mirage.running?
  end
end


def stop_mirage
  if windows?
    process_id = `tasklist /V | findstr "mirage\\ server"`.split(' ')[1]
    `taskkill /F /T /PID #{process_id}` if process_id
  else
    begin
      ["Mirage Server", 'mirage start', 'start_mirage'].each do |process_name|
        process_id = `ps aux | grep "#{process_name}" | grep -v grep`.split(' ')[1]
        system "kill -9 #{process_id}" if process_id
      end
    rescue
      puts 'Mirage is not running'
    end
  end
end

if ARGV.include?('start')

  options = parse_options(ARGV)
  mirage_client = Mirage::Client.new "http://localhost:#{options[:port]}/mirage"

  if mirage_client.running?
    puts "Mirage already running"
    exit 1
  end

  start_mirage(ARGV, mirage_client)
  begin
    mirage_client.prime
  rescue Mirage::InternalServerException => e
    puts "WARN: #{e.message}"
  end

elsif ARGV.include?('stop')
  puts "Stopping Mirage"
  stop_mirage
else
  parse_options ['--help']
  exit 1
end
